<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MiniMint on FediMint</title><link>https://fedimint.org/MiniMint/</link><description>Recent content in MiniMint on FediMint</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://fedimint.org/MiniMint/index.xml" rel="self" type="application/rss+xml"/><item><title>Architecture</title><link>https://fedimint.org/MiniMint/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fedimint.org/MiniMint/architecture/</guid><description>MiniMint is a highly experimental Rust implementation of a federated chaumian mint on top of Bitcoin. If you are interested in taking a look feel free to reach out. In the following we will try to illuminate the high level architecture. Since this is probably not the only way to build such a federated mint we will only talk about MiniMint in particular here. Other projects like SCRIT made other design decisions that are not reflected.</description></item><item><title>Consensus</title><link>https://fedimint.org/MiniMint/consensus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fedimint.org/MiniMint/consensus/</guid><description>Because it takes such a central part in a federated mint we will begin with explaining the properties of Byzantine Fault Tolerant (BFT) consensus algorithms. A byzantine fault does not only allow a party to go offline, but also to maliciously continue participating in the protocol. In the following we will use \(n\) as the total number of participants in a protocol and \(f\) as the maximum amount of faulty ones among them.</description></item><item><title>Wallet</title><link>https://fedimint.org/MiniMint/wallet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fedimint.org/MiniMint/wallet/</guid><description>To be backed by Bitcoin the federation needs a federated on-chain wallet. It is used to receive deposits that clients exchange for blind tokens and to make payouts when clients want to withdraw. Generally it is just a multisig wallet defined by a script descriptor. For example
wsh(sortedmulti(3,A,B,C,D)) where A, B, C and D are the public keys of the federation members.
Yet, notable differences exist. Other than most wallets we do not require extended public keys since we define our own derivation scheme.</description></item></channel></rss>