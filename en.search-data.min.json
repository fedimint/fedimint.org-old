[{"id":0,"href":"/","title":"","parent":"","content":" Welcome to Fedimint.org This site is intended to collect research and ideas about federated chaumian mints (or federated chaumian banks, but nobody likes banks) to scale Bitcoin while also making it more private.\nChaumian Mints One of the (if not the) earliest e-cash schemes were Chaumian mints or banks. They use blind signatures to allow the anonymous transfer of backing assets held by the mint. The basic idea is that a user can give the mint some amount x of an asset and the mint in turn blind signs x IOUs that allow the user to either withdraw the asset or exchange them for new IOUs or products. The small word \u0026ldquo;blind\u0026rdquo; does the heavy lifting here, it means that the user and mint run a cryptographic protocol that allows the user to acquire a digital signature on some data without the mint learning anything about the message or the signature so that when the mint sees one of its signatures for some message it can no longer tell to whom it was issued. This means trading these IOUs is completely anonymous.\n\u0026ldquo;Why have I never heard of this before?\u0026rdquo; you may ask and the sad answer is that it never really caught on. One big problem of chaumian mints is that they are a single point of failure and an easy target for regulation and other attacks. Most countries financial regulations disallow anonymous payments to some degree, so running a mint in the open is a bad idea. Running one anonymously brings with it the problem of trust, the operator could run away with the money at any point. This combination of problems relegated the concept to a very small, low value market, e.g. to pay for watchtower fees in lightning.\nWhat is a Federated Mint? In a federated mint the required trust is split over multiple parties. It employs a consensus algorithm and threshold cryptography to guarantee both safety and availability even in the case that some parties are compromised. That means if the participants are sufficiently distributed not even a nation state level attacker can harm the federation. Running it anonymously also becomes much more attractive since there is no single party anymore that could run away with the backing funds.\nHow does it relate to Bitcoin Bitcoin is the first asset in human history that can truly be held in a federated manner, meaning only being accessible if a certain quorum of people agrees. It is thus the perfect backing asset for a federated mint. A first, primitive version could work as follows:\ndeposit: A User sends BTC to the federation\u0026rsquo;s wallet and in turn receives the corresponding amount of tokens. transfer: The user can then pay someone else using these tokens, which works as follows: The payer selects appropriately many tokens and sends them to the payee The payee exchanges these tokens for new ones using the federated mint Only then the payee accepts the transaction, as the exchange may fail in case of a double spend withdraw: Finally any user can redeem BTC for tokens again. We see that between deposit and withdrawal there can be many internal transactions, so federated mints do not only provide excellent privacy but also scaling. One problem with this primitive version is the enormous centralization pressure it exerts, as two federated mints won\u0026rsquo;t accept each other\u0026rsquo;s tokens, making big mints more attractive. This can be mitigated by integrating with Lightning. For this the federation needs to support two more operations:\nln-send: pay an LN invoice using tokens. ln-receive: issue an invoice to a user. Once it is paid the user receives the appropriate amount of tokens. With these two operations any federated mint suddenly becomes interoperable with any other Lightning node, including other federated mints. The federation essentially becomes a hosted but federated Lightning wallet.\nWhat about centralization Yes, a federated mint requires more trust than a self-hosted Lighning node or on-chain Bitcoin. But we think that the risk can be minimized sufficiently by distributing the federation members. There are many people that can not or do not want to run their own lightning wallet, be it because of fees or maintenance effort. For these a federated mint is much preferable to centralized solutions as it protects user privacy and has no single points of failure. Systemic risks should be sufficiently mitigated by the fact that any willing group of people should be able to start their own federation.\nExisting projects We are currently aware of two efforts to build such a federated mint:\nSCRIT1: A half-finished implementation of a federated chaumian mint written in Go, developed by Frank Braun and Jonathan Logan. It does not implement BTC backing, but was the first public implementation. SCRIT2: A reimplementation of a federated chaumian mint written in Go, supporting multiple currencies, inter-currency swap transactions, receiver- and sender-initiated half-offline transactions as well as complex multiparty transactions. It is in private beta and has no direct linkage with bitcoin yet. You can read more on Jonathan\u0026rsquo;s blog. MiniMint: A (for now) private prototype still under heavy development written in Rust. It already supports rudimentary BTC backing but no Lighning integration and is generally not considered stable enough yet. If you are interested pelase reach out to elsirion. Open Transactions also deserves a honorable mention since it already allowed for the issuance of e-cash tokens backed by Bitcoin held in a multisig wallet. It does not appear to support threshold issuance of e-cash tokens though.\nResources Q\u0026amp;A An interview from HCPP21 with smuggler and elsirion about both SCRIT and MiniMint. Blockstream blogpost announcing sponsorship Bitcoin Magazine Twitter space that gives different perspectives A talk about MiniMint at Adopting Bitcoin 2021 Citadel Dispatch e45 SLP331 Eric Sirion â€“ MiniMint, Federated Mints for Bitcoin scaling and privacy Bitcoin Explained with Ruben Somsen about federated e-cash Marty Bent\u0026rsquo;s review of Federated Chaumian Mints overviewing Obi Nwosu\u0026rsquo;s and Eric Sirion\u0026rsquo;s talks at Bitcoin Miami 2022 Please feel free to open PRs for corrections and additions.\nSupport and Donations The Fedimint project is grateful for the generous support and donations we\u0026rsquo;ve received from various organisations and individuals including:\nBlockstream Obi Nwosu Einundzwanzig Human Rights Foundation Ten 31 "},{"id":1,"href":"/MiniMint/architecture/","title":"Architecture","parent":"MiniMint","content":"MiniMint is a highly experimental Rust implementation of a federated chaumian mint on top of Bitcoin. If you are interested in taking a look feel free to reach out. In the following we will try to illuminate the high level architecture. Since this is probably not the only way to build such a federated mint we will only talk about MiniMint in particular here. Other projects like SCRIT made other design decisions that are not reflected. Maybe a more comprehensive comparison can be written at a later date.\nMiniMint started out as a federated chaumian e-cash prototype. By now it is a more general framework for federated financial applications. At its core is lies the ability to agree on and process transactions. The possible input and output types of these transactions are defined by modules.\nTo implement the federated e-cash functionality there currently exist two modules:\nFediwallet: a federated on-chain wallet, supporting deposits and withdrawals Fedimint: a federated e-cash mint, supporting issuance and spending of blind signed tokens of diiferent denominations In the future other modules, e.g. to integrate Lightning, smart contracts or even a federated market place could be implemented.\nMain loop The main functionality is implemented in one big loop shown below.\nA BFT consensus algorithm is used to agree on a set of consensus items. These consist of transactions submitted by clients and other data proposed by modules. This globally agreed-upon set is then split into module-specific items and transactions. Module specific items are given to the respective modules first to prepare them for the consensus round.\nAfter that the transactions are processed by checking that the sum of input amounts is greater or equalt to outputs plus fees. If that is the case the inputs and outputs are delegated to their respective module for processing. If any is deemed invalid by a module (e.g. invalid signature) the transaction is discarded.\nAfter all transactions have been processed the next consensus proposal is prepared. It consists of transactions submitted by clients and module specific items.\nModules Each module defines an input, output and consensus item type. Modules also keep their own state using the same key-value store as MiniMint. See the database documentation for more information.\nModule Input Output Consensus Items FediWallet Deposit Withdrawal * Block height, fees and randomness beacon\n* Signatures for withdrawal transactions FediMint Coin spend Coin issuance * Partial blind signatures of issued coins Client interaction Clients communicate with federation members via a REST API. They are expected to communicate with as many members as necessary for the required assurances since some might be malicious.\nCommunication is asynchronous. First clients submit a transaction. After that they can query the transaction\u0026rsquo;s status. If the transaction is found to be faulty the status will be error and the transaction will not be submitted to the consensus. Once a transaction was included in a consensus round its state changes from proposed to accepted or error in case there was a previously undetected problem (e.g. quick double spend). Note that the accepted state is not final. Depending on the module outputs may need further action, e.g. generating blind signatures or actually submitting a withdrawal transaction. These will show up in the status as they become available.\n"},{"id":2,"href":"/categories/","title":"Categories","parent":"","content":""},{"id":3,"href":"/MiniMint/consensus/","title":"Consensus","parent":"MiniMint","content":"Because it takes such a central part in a federated mint we will begin with explaining the properties of Byzantine Fault Tolerant (BFT) consensus algorithms. A byzantine fault does not only allow a party to go offline, but also to maliciously continue participating in the protocol. In the following we will use $$n$$ as the total number of participants in a protocol and $$f$$ as the maximum amount of faulty ones among them.\nWe define a BFT consensus algorithm as an algorithm that allows all honest parties to agree on a common set of items as long as less or equal than $$f$$ of the participants are malicious. These items may be contributed by any participant and there should be no risk of targeted censorship of items. One such protocol is Honey Badger BFT (HBBFT). We will mainly use it as a reference for BFT consensus properties but note that similar but more efficient ones exist (most notably Dumbo and hybrids built on top of it).\nWe generally assume the consensus to run in rounds, producing a common subset of the contributions made by the participants. At the start of each round each participant $$i$$ is expected to propose a set of items $$C_i$$ to the consensus. After the BFT consensus algorithm has finished (note: this involves a lot of back-and-forth communication which we ignore for now) every honest participant learns the same subset $$C \\subseteq {C_1, \\dots, C_n}$$. The consensus set $$C$$ contains at least $$n-f$$ contributions from different participants. Note how this implies that if more than $$f$$ participants propose the same item said item is guaranteed to be included in the next consensus output.\nThe consensus protocols we are discussing, asynchronous ones, can only handle about $$\\frac{1}{3}$$ faulty nodes, so this will also be our assumption when building our protocol on top if not stated otherwise.\n"},{"id":4,"href":"/MiniMint/","title":"MiniMint","parent":"","content":"Minimint is an experimental implementation of a federated chaumian mint. It is still under heavy development and not open source yet. Currently only depositing, withdrawing and sending mint-internal payments works. Implementing a Lightning network integration will be the next step.\nThe asciinema recording is rather wide, so if you have a small screen it might not show the entire recorded area. We recommend to watch it in full screen mode.\n"},{"id":5,"href":"/tags/","title":"Tags","parent":"","content":""},{"id":6,"href":"/MiniMint/wallet/","title":"Wallet","parent":"MiniMint","content":"To be backed by Bitcoin the federation needs a federated on-chain wallet. It is used to receive deposits that clients exchange for blind tokens and to make payouts when clients want to withdraw. Generally it is just a multisig wallet defined by a script descriptor. For example\nwsh(sortedmulti(3,A,B,C,D)) where A, B, C and D are the public keys of the federation members.\nYet, notable differences exist. Other than most wallets we do not require extended public keys since we define our own derivation scheme. Furthermore, the wallet can not rely on local fee estimation and the local chain tip since these might be different for all members. Instead it uses the consensus algorithm to agree on these. Our particular protocol will also use a randomness beacon.\nChain tip consensus To validate transactions a wallet needs to know the current chain tip. The problem with this is that different federation members might see different chain tips either due to latency or even shallow forks.\nTo avoid the forking problem we can just define that our internal chain tip is always e.g. 100 blocks behind the real one. This should sufficiently mitigate the risk of being on different forks (bitcoin itself would be in trouble with such deep forks). But the latency problem remains.\nTo solve this we use the consensus, each round each participant does the following:\nQuery bitcoind for the current block height If the block height shrank, use the previous one Propose height - 100 as the consensus height Receive peer proposals and use median as the new consensus height Due to the assumption that less than $$\\frac{1}{3}$$ of the participants are malicious, this will always leads to a value that either was proposed by a honest participant or lies between two honest values to be chosen. Let\u0026rsquo;s say that all $$f$$ malicious proposals and $$n-2f$$ honest proposals are accepted, then $$f \u0026lt; n-2f$$ due to the previous requirement. It is easy to see that the $$f$$ malicious proposals do not suffice to meaningfully alter the median.\nOf course this assumes that all honest participants stay reasonable close to the real chain tip, but this is the task of the operators and outside our protocol.\nFee consensus We also face a similar problem when spending Bitcoin. While the destinations and amounts are generally assumed to be outputs of the consensus protocol and thus unproblematic one factor of transactions is not easily made deterministic: the fees. But to avoid depletion attacks by overpaying fees we need to agree on them.\nNaively we could use an algorithm that uses on-chain analysis to determine proper fee levels. But we only agree on a tip buried 100 blocks deep, which would make the algorithm quite unresponsive. Furthermore other algorithms that take the mempool into account may be preferable, but agreeing on the mempool is a fools errand. Instead we use a modified version of the algorithm used for the chain tip consensus. Each round each participant does the following:\nQuery bitcoind for the current optimal fee rate Propose said rate as the consensus fee rate Receive peer proposals and use median as the new consensus height The median argument works similarly and we achieve a honest consensus on fee rates.\nRandomness beacon In some cases it is useful to have access to agreed-upon, fair randomness. Thus every round every participant also proposes 32bytes of random data. The ones included in the consensus outcome are then XORed to form the round\u0026rsquo;s randomness beacon. We note that this is only safe if the items proposed to the consensus are encrypted till there is agreement on which contributions will be included. This is the case for HBBFT. Otherwise an attacker could wait for the other participants to announce their contribution and then adaptively chose his own to influence the outcome.\nAddress Derivation To allow clients to generate deposit addresses independent of the federation we do not use BIP32 derivation to generate new addresses from the wallet descriptor, but a custom derivation scheme. We instead use a pay-to-contract construction where a \u0026ldquo;contract\u0026rdquo; is hashed and added to all keys in the descriptor (added in the exponent in case of the pub key). A descriptor with derived keys can then trivially be transformed into an address.\nIn MiniMint the \u0026ldquo;contract\u0026rdquo; is just a public key that can later be used to tie the deposit to a issuance transaction.\nReceiving Bitcoin When depositing Bitcoin into the federation a client proceeds as follows:\nGenerate public/secret key pair Tweak federation descriptor with public key Send BTC to the resulting address Generate TxOutProof and fetch raw transaction. These compact data structures allow the federation to verify the deposit with only the block hashes being synced and not the whole chain. The tweak together with the TxOutProof and the raw transaction can now be sent to the federation to prove money was deposited. The federation should require a signature using the secret key. Note that only once the federation is in possession of the tweak they can actually spend the funds as it is also needed to tweak the private keys.\nSending Bitcoin Once the federation agrees on paying Bitcoin to a set of destinations every participant deterministically selects the necessary outputs. The previously agreed-upon fee rate is used to determine the fee. In case a change address is needed the randomness beacon is used to derive a random change address just as a deposit address would be derived.\nThis transaction is then signed by each participant individually and the signatures broadcasted via the consensus protocol. Note that due to the transaction being generated deterministically it does not need to be exchanged itself.\nAfter receiving sufficient signatures each party can assemble the final transaction and broadcast it.\n"}]